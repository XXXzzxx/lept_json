## 'null','true', 'false'解析
1. 这个只需要进行一一比对就行了
2. 调用了函数lept_parse_literal();

## 字符串的解析
1. 总流程就是遇到第一个 `'"'` 号就把后面的字符串都push到栈里面去,直到遇到了第二个引号,表示这个字符串结束了.这时候就把栈里面的push出来
2. 需要注意的是,这个里面会涉及'\u' 的解析。就比如一个字符串 `"我是一个好人,但是A说"我是一个坏人"`  这时候这个引号就需要转义字符进行解析。

## 数字解析
1. 负号(可选) 
2. 情况1 纯单个0 或者一串数字  + (一个小数点   +  一串数字)(可选)
3. 在情况1下 + e/E + 正负号(可选) +  非0开头的以串数字

## '\u'解析
1. 先检测Unicode格式 \u 后加4个十六进制数
2. 代码中每次使u*16  `*u = *u << 4; `  使用u计算unicode(字符转数字)值, 后面还使用了或(|)操作其实也就是相当于是加操作
3. 如果格式正确进行判断是否有低代理项, 如果有检查格式正确后, 使用`u = 0x10000 + (uh - 0xD800) * 0x400 + (ul - 0xDC00);`  计算码点
4. 最后把码点编码成utf-8
5. unicode转utf-8   就是把十六进制转化成二进制, 但是不同区间的二进制使用的格式以及长度是不一样的

## 数组解析
1. 指针但是又是数组,第一次接触感觉挺神奇的
2. 比如[ [123 , 1 ], [] , [] ]  因为用了递归,遇到第一个']'会malloc一个`2*sizeof(lept_value)`的空间用来存`123 和 1`这个两个number
3. 然后连续再malloc一个存空的array两次, 最后malloc一个`3*sizeof(lept_value)`的空间
4. 中间还需要用到栈来暂时存放,push和pop都需要在外面配合memcpy来使用.  
5. push返回的是当前栈顶的后一个位置 pop返回的是被pop出去的字符串的第一位地址